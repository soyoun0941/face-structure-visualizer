<!DOCTYPE html>
<html>
<head>
  <title>FaceMesh êµ¬ì¡° ë³´ê¸°</title>
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh/face_mesh.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>
  <style>
    body { font-family: sans-serif; text-align: center; padding: 20px; }
    canvas { margin-top: 10px; border-radius: 8px; }
    .error { color: red; margin-top: 20px; }
    .analysis-box {
      margin-top: 20px;
      padding: 15px;
      background-color: #f4f4f4;
      border-radius: 10px;
      max-width: 600px;
      margin-left: auto;
      margin-right: auto;
      text-align: left;
    }
    .interpretation {
      margin-top: 10px;
      font-style: italic;
      color: #333;
    }
  </style>
</head>
<body>
  <h2>ğŸ“¸ ë‚´ ì–¼êµ´ êµ¬ì¡° ì‹œê°í™”</h2>
  <canvas class="output_canvas" width="640" height="480"></canvas>
  <div class="error" id="errorMsg"></div>
  <div class="analysis-box" id="faceAnalysis" style="display:none">
    <h3>ğŸ” ì–¼êµ´ì˜ êµ¬ì¡°ì  íŠ¹ì§•</h3>
    <ul id="analysisText"></ul>
    <div class="interpretation" id="analysisInterpretation"></div>
  </div>

  <script>
    const canvasElement = document.querySelector('.output_canvas');
    const canvasCtx = canvasElement.getContext('2d');
    const errorMsg = document.getElementById('errorMsg');
    const faceAnalysis = document.getElementById('faceAnalysis');
    const analysisText = document.getElementById('analysisText');
    const analysisInterpretation = document.getElementById('analysisInterpretation');

    function calculateDistance(p1, p2) {
      return Math.sqrt(Math.pow(p1.x - p2.x, 2) + Math.pow(p1.y - p2.y, 2));
    }

    function classifyRelative(value, avg, tol = 0.012) {
      const diff = value - avg;
      if (Math.abs(diff) <= tol) return 'í‰ê·  ë²”ìœ„ì…ë‹ˆë‹¤';
      if (diff < -tol) return 'í‰ê· ë³´ë‹¤ ì¢ì€ í¸ì…ë‹ˆë‹¤';
      return 'í‰ê· ë³´ë‹¤ ë„“ì€ í¸ì…ë‹ˆë‹¤';
    }
    <li><strong>ëˆˆ ì‚¬ì´ ë¹„ìœ¨:</strong> ${(ratios.eyeDistance / ratios.horizontal).toFixed(3)} (${ratios.eyeComment})</li>


    function classifyFaceShape(ratio, jawWidthRatio) {
      if (jawWidthRatio < 0.8 && ratio < 1.2) return 'ê³„ë€í˜•';
      if (jawWidthRatio > 0.9 && ratio < 1.2) return 'ë‘¥ê·¼í˜•';
      if (jawWidthRatio < 0.8 && ratio >= 1.2 && ratio < 1.35) return 'íƒ€ì›í˜•';
      if (ratio >= 1.35) return 'ê¸´í˜•';
      return 'ê¸°íƒ€í˜•';
    }

    function calculateRatios(landmarks) {
      const chin = landmarks[152];
      const forehead = landmarks[10];
      const leftCheek = landmarks[234];
      const rightCheek = landmarks[454];
      const leftEyeInner = landmarks[133];
      const rightEyeInner = landmarks[362];
      const noseTop = landmarks[6];
      const noseBottom = landmarks[2];
      const mouthLeft = landmarks[61];
      const mouthRight = landmarks[291];
      const jawLeft = landmarks[234];
      const jawRight = landmarks[454];
      const eyeOuterLeft = landmarks[130];
      const eyeOuterRight = landmarks[359];

      const vertical = calculateDistance(chin, forehead);
      const horizontal = calculateDistance(leftCheek, rightCheek);
      const eyeDistance = calculateDistance(leftEyeInner, rightEyeInner);
      const noseLength = calculateDistance(noseTop, noseBottom);
      const mouthWidth = calculateDistance(mouthLeft, mouthRight);
      const jawWidth = calculateDistance(jawLeft, jawRight);
      const eyeTilt = Math.atan2(eyeOuterRight.y - eyeOuterLeft.y, eyeOuterRight.x - eyeOuterLeft.x) * 180 / Math.PI;

      const verticalToHorizontal = vertical / horizontal;
      const eyeRatio = eyeDistance / horizontal;
      const noseRatio = noseLength / vertical;
      const mouthRatio = mouthWidth / horizontal;
      const jawRatio = jawWidth / horizontal;

      return {
        vertical: vertical.toFixed(2),
        horizontal: horizontal.toFixed(2),
        verticalToHorizontal: verticalToHorizontal.toFixed(2),
        eyeDistance: eyeDistance.toFixed(2),
        noseLength: noseLength.toFixed(2),
        mouthWidth: mouthWidth.toFixed(2),
        jawWidth: jawWidth.toFixed(2),
        eyeTilt: eyeTilt.toFixed(2),
        shape: classifyFaceShape(verticalToHorizontal, jawRatio),
        eyeComment: classifyRelative(eyeRatio, 0.275),
        noseComment: classifyRelative(noseRatio, 0.25),
        mouthComment: classifyRelative(mouthRatio, 0.38),
        jawComment: classifyRelative(jawRatio, 0.85)
      };
    }

    const faceMesh = new FaceMesh({locateFile: file => `https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh/${file}`});
    faceMesh.setOptions({
      maxNumFaces: 1,
      refineLandmarks: true,
      minDetectionConfidence: 0.5,
      minTrackingConfidence: 0.5
    });

    faceMesh.onResults(results => {
      canvasCtx.save();
      canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);
      canvasCtx.drawImage(results.image, 0, 0, canvasElement.width, canvasElement.height);

      if (results.multiFaceLandmarks.length > 0) {
        const landmarks = results.multiFaceLandmarks[0];
        const ratios = calculateRatios(landmarks);

        analysisText.innerHTML = `
          <li><strong>ì„¸ë¡œ ê¸¸ì´:</strong> ${ratios.vertical}px</li>
          <li><strong>ê°€ë¡œ ê¸¸ì´:</strong> ${ratios.horizontal}px</li>
          <li><strong>ì„¸ë¡œ:ê°€ë¡œ ë¹„ìœ¨:</strong> ${ratios.verticalToHorizontal}</li>
          <li><strong>ëˆˆ ì‚¬ì´ ê±°ë¦¬:</strong> ${ratios.eyeDistance}px (${ratios.eyeComment})</li>
          <li><strong>ì½” ê¸¸ì´:</strong> ${ratios.noseLength}px (${ratios.noseComment})</li>
          <li><strong>ì…ê¼¬ë¦¬ ë„ˆë¹„:</strong> ${ratios.mouthWidth}px (${ratios.mouthComment})</li>
          <li><strong>í„± ë„ˆë¹„:</strong> ${ratios.jawWidth}px (${ratios.jawComment})</li>
          <li><strong>ëˆˆê¼¬ë¦¬ ê¸°ìš¸ê¸°:</strong> ${ratios.eyeTilt}Â°</li>
          <li><strong>ì¶”ì • ì–¼êµ´í˜•:</strong> ${ratios.shape}</li>`;

        analysisInterpretation.innerHTML = `
          ì–¼êµ´í˜•ì€ <strong>${ratios.shape}</strong>ì´ë©°,<br>
          ëˆˆ ì‚¬ì´ ê°„ê²©ì€ ${ratios.eyeComment}, ì½” ê¸¸ì´ëŠ” ${ratios.noseComment},<br>
          ì…ê¼¬ë¦¬ ë„ˆë¹„ëŠ” ${ratios.mouthComment}, í„± ë„ˆë¹„ëŠ” ${ratios.jawComment}ì…ë‹ˆë‹¤.`;

        faceAnalysis.style.display = 'block';
      }

      canvasCtx.restore();
    });

    async function setupCamera() {
      const videoElement = document.createElement('video');
      videoElement.style.display = 'none';
      document.body.appendChild(videoElement);

      try {
        const stream = await navigator.mediaDevices.getUserMedia({ video: true });
        videoElement.srcObject = stream;
        return new Promise((resolve) => {
          videoElement.onloadedmetadata = () => resolve(videoElement);
        });
      } catch (err) {
        errorMsg.textContent = 'ğŸš« ì¹´ë©”ë¼ ì ‘ê·¼ì´ ê±°ë¶€ë˜ì—ˆìŠµë‹ˆë‹¤.';
        throw err;
      }
    }

    setupCamera().then(video => {
      new Camera(video, {
        onFrame: async () => await faceMesh.send({image: video}),
        width: 640,
        height: 480
      }).start();
    });
  </script>
</body>
</html>
